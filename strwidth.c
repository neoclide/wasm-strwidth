#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

#define NUL '\000'

typedef unsigned int int_u;
typedef unsigned char char_u;

struct interval {
  long first;
  long last;
};

static _Bool ambiguousAsDouble = false;

// Sorted list of non-overlapping intervals of East Asian Ambiguous
// characters, generated with ../runtime/tools/unicode.vim.
static struct interval ambiguous[] = {
    {0x00a1, 0x00a1},   {0x00a4, 0x00a4},    {0x00a7, 0x00a8},
    {0x00aa, 0x00aa},   {0x00ad, 0x00ae},    {0x00b0, 0x00b4},
    {0x00b6, 0x00ba},   {0x00bc, 0x00bf},    {0x00c6, 0x00c6},
    {0x00d0, 0x00d0},   {0x00d7, 0x00d8},    {0x00de, 0x00e1},
    {0x00e6, 0x00e6},   {0x00e8, 0x00ea},    {0x00ec, 0x00ed},
    {0x00f0, 0x00f0},   {0x00f2, 0x00f3},    {0x00f7, 0x00fa},
    {0x00fc, 0x00fc},   {0x00fe, 0x00fe},    {0x0101, 0x0101},
    {0x0111, 0x0111},   {0x0113, 0x0113},    {0x011b, 0x011b},
    {0x0126, 0x0127},   {0x012b, 0x012b},    {0x0131, 0x0133},
    {0x0138, 0x0138},   {0x013f, 0x0142},    {0x0144, 0x0144},
    {0x0148, 0x014b},   {0x014d, 0x014d},    {0x0152, 0x0153},
    {0x0166, 0x0167},   {0x016b, 0x016b},    {0x01ce, 0x01ce},
    {0x01d0, 0x01d0},   {0x01d2, 0x01d2},    {0x01d4, 0x01d4},
    {0x01d6, 0x01d6},   {0x01d8, 0x01d8},    {0x01da, 0x01da},
    {0x01dc, 0x01dc},   {0x0251, 0x0251},    {0x0261, 0x0261},
    {0x02c4, 0x02c4},   {0x02c7, 0x02c7},    {0x02c9, 0x02cb},
    {0x02cd, 0x02cd},   {0x02d0, 0x02d0},    {0x02d8, 0x02db},
    {0x02dd, 0x02dd},   {0x02df, 0x02df},    {0x0300, 0x036f},
    {0x0391, 0x03a1},   {0x03a3, 0x03a9},    {0x03b1, 0x03c1},
    {0x03c3, 0x03c9},   {0x0401, 0x0401},    {0x0410, 0x044f},
    {0x0451, 0x0451},   {0x2010, 0x2010},    {0x2013, 0x2016},
    {0x2018, 0x2019},   {0x201c, 0x201d},    {0x2020, 0x2022},
    {0x2024, 0x2027},   {0x2030, 0x2030},    {0x2032, 0x2033},
    {0x2035, 0x2035},   {0x203b, 0x203b},    {0x203e, 0x203e},
    {0x2074, 0x2074},   {0x207f, 0x207f},    {0x2081, 0x2084},
    {0x20ac, 0x20ac},   {0x2103, 0x2103},    {0x2105, 0x2105},
    {0x2109, 0x2109},   {0x2113, 0x2113},    {0x2116, 0x2116},
    {0x2121, 0x2122},   {0x2126, 0x2126},    {0x212b, 0x212b},
    {0x2153, 0x2154},   {0x215b, 0x215e},    {0x2160, 0x216b},
    {0x2170, 0x2179},   {0x2189, 0x2189},    {0x2190, 0x2199},
    {0x21b8, 0x21b9},   {0x21d2, 0x21d2},    {0x21d4, 0x21d4},
    {0x21e7, 0x21e7},   {0x2200, 0x2200},    {0x2202, 0x2203},
    {0x2207, 0x2208},   {0x220b, 0x220b},    {0x220f, 0x220f},
    {0x2211, 0x2211},   {0x2215, 0x2215},    {0x221a, 0x221a},
    {0x221d, 0x2220},   {0x2223, 0x2223},    {0x2225, 0x2225},
    {0x2227, 0x222c},   {0x222e, 0x222e},    {0x2234, 0x2237},
    {0x223c, 0x223d},   {0x2248, 0x2248},    {0x224c, 0x224c},
    {0x2252, 0x2252},   {0x2260, 0x2261},    {0x2264, 0x2267},
    {0x226a, 0x226b},   {0x226e, 0x226f},    {0x2282, 0x2283},
    {0x2286, 0x2287},   {0x2295, 0x2295},    {0x2299, 0x2299},
    {0x22a5, 0x22a5},   {0x22bf, 0x22bf},    {0x2312, 0x2312},
    {0x2460, 0x24e9},   {0x24eb, 0x254b},    {0x2550, 0x2573},
    {0x2580, 0x258f},   {0x2592, 0x2595},    {0x25a0, 0x25a1},
    {0x25a3, 0x25a9},   {0x25b2, 0x25b3},    {0x25b6, 0x25b7},
    {0x25bc, 0x25bd},   {0x25c0, 0x25c1},    {0x25c6, 0x25c8},
    {0x25cb, 0x25cb},   {0x25ce, 0x25d1},    {0x25e2, 0x25e5},
    {0x25ef, 0x25ef},   {0x2605, 0x2606},    {0x2609, 0x2609},
    {0x260e, 0x260f},   {0x261c, 0x261c},    {0x261e, 0x261e},
    {0x2640, 0x2640},   {0x2642, 0x2642},    {0x2660, 0x2661},
    {0x2663, 0x2665},   {0x2667, 0x266a},    {0x266c, 0x266d},
    {0x266f, 0x266f},   {0x269e, 0x269f},    {0x26bf, 0x26bf},
    {0x26c6, 0x26cd},   {0x26cf, 0x26d3},    {0x26d5, 0x26e1},
    {0x26e3, 0x26e3},   {0x26e8, 0x26e9},    {0x26eb, 0x26f1},
    {0x26f4, 0x26f4},   {0x26f6, 0x26f9},    {0x26fb, 0x26fc},
    {0x26fe, 0x26ff},   {0x273d, 0x273d},    {0x2776, 0x277f},
    {0x2b56, 0x2b59},   {0x3248, 0x324f},    {0xe000, 0xf8ff},
    {0xfe00, 0xfe0f},   {0xfffd, 0xfffd},    {0x1f100, 0x1f10a},
    {0x1f110, 0x1f12d}, {0x1f130, 0x1f169},  {0x1f170, 0x1f18d},
    {0x1f18f, 0x1f190}, {0x1f19b, 0x1f1ac},  {0xe0100, 0xe01ef},
    {0xf0000, 0xffffd}, {0x100000, 0x10fffd}};

/*
 * Lookup table to quickly get the length in bytes of a UTF-8 character from
 * the first byte of a UTF-8 string.
 * Bytes which are illegal when used as the first byte have a 1.
 * The NUL byte has length 1.
 */
static char utf8len_tab[256] = {
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 1, 1,
};

/*
 * Like utf8len_tab above, but using a zero for illegal lead bytes.
 */
static char utf8len_tab_zero[256] = {
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 0, 0,
};

/*
 * Return TRUE if "c" is in "table[size / sizeof(struct interval)]".
 */
static _Bool intable(struct interval *table, size_t size, int c) {
  int mid, bot, top;

  // first quick check for Latin1 etc. characters
  if (c < table[0].first)
    return false;

  // binary search in table
  bot = 0;
  top = (int)(size / sizeof(struct interval) - 1);
  while (top >= bot) {
    mid = (bot + top) / 2;
    if (table[mid].last < c)
      bot = mid + 1;
    else if (table[mid].first > c)
      top = mid - 1;
    else
      return true;
  }
  return false;
}

/*
 * Return TRUE for characters that can be displayed in a normal way.
 * Only for characters of 0x100 and above!
 */
_Bool utf_printable(int c) {
  static struct interval nonprint[] = {
      {0x070f, 0x070f}, {0x180b, 0x180e}, {0x200b, 0x200f},
      {0x202a, 0x202e}, {0x2060, 0x206f}, {0xd800, 0xdfff},
      {0xfeff, 0xfeff}, {0xfff9, 0xfffb}, {0xfffe, 0xffff}};

  return !intable(nonprint, sizeof(nonprint), c);
}

/*
 * Return TRUE if 'c' is a printable character.
 * Assume characters above 0x100 are printable (multi-byte), except for
 * Unicode.
 */
_Bool vim_isprintc(int c) {
  if (c >= 0x100)
    return utf_printable(c);
  if (c >= 0xa0)
    return true;
  return c >= ' ' && c <= '~';
}

/*
 * Get the length of a UTF-8 byte sequence, not including any following
 * composing characters.
 * Returns 0 for "".
 * Returns 1 for an illegal byte sequence.
 */
int utf_ptr2len(char_u *p) {
  int len;
  int i;

  if (*p == NUL)
    return 0;
  len = utf8len_tab[*p];
  for (i = 1; i < len; ++i)
    if ((p[i] & 0xc0) != 0x80)
      return 1;
  return len;
}

/*
 * Convert a UTF-8 byte sequence to a character number.
 * If the sequence is illegal or truncated by a NUL the first byte is
 * returned.
 * For an overlong sequence this may return zero.
 * Does not include composing characters, of course.
 */
int utf_ptr2char(char_u *p) {
  int len;

  if (p[0] < 0x80) // be quick for ASCII
    return p[0];

  len = utf8len_tab_zero[p[0]];
  if (len > 1 && (p[1] & 0xc0) == 0x80) {
    if (len == 2)
      return ((p[0] & 0x1f) << 6) + (p[1] & 0x3f);
    if ((p[2] & 0xc0) == 0x80) {
      if (len == 3)
        return ((p[0] & 0x0f) << 12) + ((p[1] & 0x3f) << 6) + (p[2] & 0x3f);
      if ((p[3] & 0xc0) == 0x80) {
        if (len == 4)
          return ((p[0] & 0x07) << 18) + ((p[1] & 0x3f) << 12) +
                 ((p[2] & 0x3f) << 6) + (p[3] & 0x3f);
        if ((p[4] & 0xc0) == 0x80) {
          if (len == 5)
            return ((p[0] & 0x03) << 24) + ((p[1] & 0x3f) << 18) +
                   ((p[2] & 0x3f) << 12) + ((p[3] & 0x3f) << 6) + (p[4] & 0x3f);
          if ((p[5] & 0xc0) == 0x80 && len == 6)
            return ((p[0] & 0x01) << 30) + ((p[1] & 0x3f) << 24) +
                   ((p[2] & 0x3f) << 18) + ((p[3] & 0x3f) << 12) +
                   ((p[4] & 0x3f) << 6) + (p[5] & 0x3f);
        }
      }
    }
  }
  // Illegal value, just return the first byte
  return p[0];
}

int char2cells(int c) {
  if (c < ' ')
    return 2;
  if (c <= '~')
    return 1;
  // vim print <Del> as <80>kD
  return 6;
}

/*
 * For UTF-8 character "c" return 2 for a double-width character, 1 for others.
 * Returns 4 or 6 for an unprintable character.
 * Is only correct for characters >= 0x80.
 * When ambiguousAsDouble is true, return 2 for a character with East Asian
 * Width class 'A'(mbiguous).
 */
int utf_char2cells(int c) {
  // Sorted list of non-overlapping intervals of East Asian double width
  // characters, generated with ../runtime/tools/unicode.vim.
  static struct interval doublewidth[] = {
      {0x1100, 0x115f},   {0x231a, 0x231b},   {0x2329, 0x232a},
      {0x23e9, 0x23ec},   {0x23f0, 0x23f0},   {0x23f3, 0x23f3},
      {0x25fd, 0x25fe},   {0x2614, 0x2615},   {0x2648, 0x2653},
      {0x267f, 0x267f},   {0x2693, 0x2693},   {0x26a1, 0x26a1},
      {0x26aa, 0x26ab},   {0x26bd, 0x26be},   {0x26c4, 0x26c5},
      {0x26ce, 0x26ce},   {0x26d4, 0x26d4},   {0x26ea, 0x26ea},
      {0x26f2, 0x26f3},   {0x26f5, 0x26f5},   {0x26fa, 0x26fa},
      {0x26fd, 0x26fd},   {0x2705, 0x2705},   {0x270a, 0x270b},
      {0x2728, 0x2728},   {0x274c, 0x274c},   {0x274e, 0x274e},
      {0x2753, 0x2755},   {0x2757, 0x2757},   {0x2795, 0x2797},
      {0x27b0, 0x27b0},   {0x27bf, 0x27bf},   {0x2b1b, 0x2b1c},
      {0x2b50, 0x2b50},   {0x2b55, 0x2b55},   {0x2e80, 0x2e99},
      {0x2e9b, 0x2ef3},   {0x2f00, 0x2fd5},   {0x2ff0, 0x2ffb},
      {0x3000, 0x303e},   {0x3041, 0x3096},   {0x3099, 0x30ff},
      {0x3105, 0x312f},   {0x3131, 0x318e},   {0x3190, 0x31e3},
      {0x31f0, 0x321e},   {0x3220, 0x3247},   {0x3250, 0x4dbf},
      {0x4e00, 0xa48c},   {0xa490, 0xa4c6},   {0xa960, 0xa97c},
      {0xac00, 0xd7a3},   {0xf900, 0xfaff},   {0xfe10, 0xfe19},
      {0xfe30, 0xfe52},   {0xfe54, 0xfe66},   {0xfe68, 0xfe6b},
      {0xff01, 0xff60},   {0xffe0, 0xffe6},   {0x16fe0, 0x16fe3},
      {0x16ff0, 0x16ff1}, {0x17000, 0x187f7}, {0x18800, 0x18cd5},
      {0x18d00, 0x18d08}, {0x1b000, 0x1b11e}, {0x1b150, 0x1b152},
      {0x1b164, 0x1b167}, {0x1b170, 0x1b2fb}, {0x1f004, 0x1f004},
      {0x1f0cf, 0x1f0cf}, {0x1f18e, 0x1f18e}, {0x1f191, 0x1f19a},
      {0x1f200, 0x1f202}, {0x1f210, 0x1f23b}, {0x1f240, 0x1f248},
      {0x1f250, 0x1f251}, {0x1f260, 0x1f265}, {0x1f300, 0x1f320},
      {0x1f32d, 0x1f335}, {0x1f337, 0x1f37c}, {0x1f37e, 0x1f393},
      {0x1f3a0, 0x1f3ca}, {0x1f3cf, 0x1f3d3}, {0x1f3e0, 0x1f3f0},
      {0x1f3f4, 0x1f3f4}, {0x1f3f8, 0x1f43e}, {0x1f440, 0x1f440},
      {0x1f442, 0x1f4fc}, {0x1f4ff, 0x1f53d}, {0x1f54b, 0x1f54e},
      {0x1f550, 0x1f567}, {0x1f57a, 0x1f57a}, {0x1f595, 0x1f596},
      {0x1f5a4, 0x1f5a4}, {0x1f5fb, 0x1f64f}, {0x1f680, 0x1f6c5},
      {0x1f6cc, 0x1f6cc}, {0x1f6d0, 0x1f6d2}, {0x1f6d5, 0x1f6d7},
      {0x1f6eb, 0x1f6ec}, {0x1f6f4, 0x1f6fc}, {0x1f7e0, 0x1f7eb},
      {0x1f90c, 0x1f93a}, {0x1f93c, 0x1f945}, {0x1f947, 0x1f978},
      {0x1f97a, 0x1f9cb}, {0x1f9cd, 0x1f9ff}, {0x1fa70, 0x1fa74},
      {0x1fa78, 0x1fa7a}, {0x1fa80, 0x1fa86}, {0x1fa90, 0x1faa8},
      {0x1fab0, 0x1fab6}, {0x1fac0, 0x1fac2}, {0x1fad0, 0x1fad6},
      {0x20000, 0x2fffd}, {0x30000, 0x3fffd}};

  // Sorted list of non-overlapping intervals of Emoji characters that don't
  // have ambiguous or double width,
  // based on http://unicode.org/emoji/charts/emoji-list.html
  static struct interval emoji_wide[] = {
      {0x23ed, 0x23ef},
      {0x23f1, 0x23f2},
      {0x23f8, 0x23fa},
      {0x24c2, 0x24c2},
      {0x261d, 0x261d},
      {0x26c8, 0x26c8},
      {0x26cf, 0x26cf},
      {0x26d1, 0x26d1},
      {0x26d3, 0x26d3},
      {0x26e9, 0x26e9},
      {0x26f0, 0x26f1},
      {0x26f7, 0x26f9},
      {0x270c, 0x270d},
      {0x2934, 0x2935},
      {0x1f170, 0x1f189},
      {0x1f1e6, 0x1f1ff},
      {0x1f321, 0x1f321},
      {0x1f324, 0x1f32c},
      {0x1f336, 0x1f336},
      {0x1f37d, 0x1f37d},
      {0x1f396, 0x1f397},
      {0x1f399, 0x1f39b},
      {0x1f39e, 0x1f39f},
      {0x1f3cb, 0x1f3ce},
      {0x1f3d4, 0x1f3df},
      {0x1f3f3, 0x1f3f5},
      {0x1f3f7, 0x1f3f7},
      {0x1f43f, 0x1f43f},
      {0x1f441, 0x1f441},
      {0x1f4fd, 0x1f4fd},
      {0x1f549, 0x1f54a},
      {0x1f56f, 0x1f570},
      {0x1f573, 0x1f579},
      {0x1f587, 0x1f587},
      {0x1f58a, 0x1f58d},
      {0x1f590, 0x1f590},
      {0x1f5a5, 0x1f5a5},
      {0x1f5a8, 0x1f5a8},
      {0x1f5b1, 0x1f5b2},
      {0x1f5bc, 0x1f5bc},
      {0x1f5c2, 0x1f5c4},
      {0x1f5d1, 0x1f5d3},
      {0x1f5dc, 0x1f5de},
      {0x1f5e1, 0x1f5e1},
      {0x1f5e3, 0x1f5e3},
      {0x1f5e8, 0x1f5e8},
      {0x1f5ef, 0x1f5ef},
      {0x1f5f3, 0x1f5f3},
      {0x1f5fa, 0x1f5fa},
      {0x1f6cb, 0x1f6cf},
      {0x1f6e0, 0x1f6e5},
      {0x1f6e9, 0x1f6e9},
      {0x1f6f0, 0x1f6f0},
      {0x1f6f3, 0x1f6f3}

      // Include SF Symbols characters, which should be rendered as
      // double-width. All of them are in the Supplementary Private Use
      // Area-B range. The exact range was determined by downloading the "SF
      // Symbols" app from Apple, and then selecting all symbols, copying
      // them out, and inspecting the unicode values of them.
      ,
      {0x100000, 0x100d7f}};

  if (c >= 0x100) {
    // TODO we don't have api setcellwidths()
    // int n;
    //
    // n = cw_value(c);
    // if (n != 0)
    //   return n;

    if (!utf_printable(c))
      return 6; // unprintable, displays <xxxx>
    if (intable(doublewidth, sizeof(doublewidth), c))
      return 2;
    if (intable(emoji_wide, sizeof(emoji_wide), c))
      return 2;
  }

  // Characters below 0x100 are influenced by 'isprint' option
  else if (c >= 0x80 && !vim_isprintc(c))
    return 4; // unprintable, displays <xx>

  if (c >= 0x80 && ambiguousAsDouble &&
      intable(ambiguous, sizeof(ambiguous), c))
    return 2;

  return 1;
}

/*
 * Return TRUE if "c" is a composing UTF-8 character.  This means it will be
 * drawn on top of the preceding character.
 * Based on code from Markus Kuhn.
 */
int utf_iscomposing(int c) {
  // Sorted list of non-overlapping intervals.
  // Generated by ../runtime/tools/unicode.vim.
  static struct interval combining[] = {
      {0x0300, 0x036f},   {0x0483, 0x0489},   {0x0591, 0x05bd},
      {0x05bf, 0x05bf},   {0x05c1, 0x05c2},   {0x05c4, 0x05c5},
      {0x05c7, 0x05c7},   {0x0610, 0x061a},   {0x064b, 0x065f},
      {0x0670, 0x0670},   {0x06d6, 0x06dc},   {0x06df, 0x06e4},
      {0x06e7, 0x06e8},   {0x06ea, 0x06ed},   {0x0711, 0x0711},
      {0x0730, 0x074a},   {0x07a6, 0x07b0},   {0x07eb, 0x07f3},
      {0x07fd, 0x07fd},   {0x0816, 0x0819},   {0x081b, 0x0823},
      {0x0825, 0x0827},   {0x0829, 0x082d},   {0x0859, 0x085b},
      {0x08d3, 0x08e1},   {0x08e3, 0x0903},   {0x093a, 0x093c},
      {0x093e, 0x094f},   {0x0951, 0x0957},   {0x0962, 0x0963},
      {0x0981, 0x0983},   {0x09bc, 0x09bc},   {0x09be, 0x09c4},
      {0x09c7, 0x09c8},   {0x09cb, 0x09cd},   {0x09d7, 0x09d7},
      {0x09e2, 0x09e3},   {0x09fe, 0x09fe},   {0x0a01, 0x0a03},
      {0x0a3c, 0x0a3c},   {0x0a3e, 0x0a42},   {0x0a47, 0x0a48},
      {0x0a4b, 0x0a4d},   {0x0a51, 0x0a51},   {0x0a70, 0x0a71},
      {0x0a75, 0x0a75},   {0x0a81, 0x0a83},   {0x0abc, 0x0abc},
      {0x0abe, 0x0ac5},   {0x0ac7, 0x0ac9},   {0x0acb, 0x0acd},
      {0x0ae2, 0x0ae3},   {0x0afa, 0x0aff},   {0x0b01, 0x0b03},
      {0x0b3c, 0x0b3c},   {0x0b3e, 0x0b44},   {0x0b47, 0x0b48},
      {0x0b4b, 0x0b4d},   {0x0b55, 0x0b57},   {0x0b62, 0x0b63},
      {0x0b82, 0x0b82},   {0x0bbe, 0x0bc2},   {0x0bc6, 0x0bc8},
      {0x0bca, 0x0bcd},   {0x0bd7, 0x0bd7},   {0x0c00, 0x0c04},
      {0x0c3e, 0x0c44},   {0x0c46, 0x0c48},   {0x0c4a, 0x0c4d},
      {0x0c55, 0x0c56},   {0x0c62, 0x0c63},   {0x0c81, 0x0c83},
      {0x0cbc, 0x0cbc},   {0x0cbe, 0x0cc4},   {0x0cc6, 0x0cc8},
      {0x0cca, 0x0ccd},   {0x0cd5, 0x0cd6},   {0x0ce2, 0x0ce3},
      {0x0d00, 0x0d03},   {0x0d3b, 0x0d3c},   {0x0d3e, 0x0d44},
      {0x0d46, 0x0d48},   {0x0d4a, 0x0d4d},   {0x0d57, 0x0d57},
      {0x0d62, 0x0d63},   {0x0d81, 0x0d83},   {0x0dca, 0x0dca},
      {0x0dcf, 0x0dd4},   {0x0dd6, 0x0dd6},   {0x0dd8, 0x0ddf},
      {0x0df2, 0x0df3},   {0x0e31, 0x0e31},   {0x0e34, 0x0e3a},
      {0x0e47, 0x0e4e},   {0x0eb1, 0x0eb1},   {0x0eb4, 0x0ebc},
      {0x0ec8, 0x0ecd},   {0x0f18, 0x0f19},   {0x0f35, 0x0f35},
      {0x0f37, 0x0f37},   {0x0f39, 0x0f39},   {0x0f3e, 0x0f3f},
      {0x0f71, 0x0f84},   {0x0f86, 0x0f87},   {0x0f8d, 0x0f97},
      {0x0f99, 0x0fbc},   {0x0fc6, 0x0fc6},   {0x102b, 0x103e},
      {0x1056, 0x1059},   {0x105e, 0x1060},   {0x1062, 0x1064},
      {0x1067, 0x106d},   {0x1071, 0x1074},   {0x1082, 0x108d},
      {0x108f, 0x108f},   {0x109a, 0x109d},   {0x135d, 0x135f},
      {0x1712, 0x1714},   {0x1732, 0x1734},   {0x1752, 0x1753},
      {0x1772, 0x1773},   {0x17b4, 0x17d3},   {0x17dd, 0x17dd},
      {0x180b, 0x180d},   {0x1885, 0x1886},   {0x18a9, 0x18a9},
      {0x1920, 0x192b},   {0x1930, 0x193b},   {0x1a17, 0x1a1b},
      {0x1a55, 0x1a5e},   {0x1a60, 0x1a7c},   {0x1a7f, 0x1a7f},
      {0x1ab0, 0x1ac0},   {0x1b00, 0x1b04},   {0x1b34, 0x1b44},
      {0x1b6b, 0x1b73},   {0x1b80, 0x1b82},   {0x1ba1, 0x1bad},
      {0x1be6, 0x1bf3},   {0x1c24, 0x1c37},   {0x1cd0, 0x1cd2},
      {0x1cd4, 0x1ce8},   {0x1ced, 0x1ced},   {0x1cf4, 0x1cf4},
      {0x1cf7, 0x1cf9},   {0x1dc0, 0x1df9},   {0x1dfb, 0x1dff},
      {0x20d0, 0x20f0},   {0x2cef, 0x2cf1},   {0x2d7f, 0x2d7f},
      {0x2de0, 0x2dff},   {0x302a, 0x302f},   {0x3099, 0x309a},
      {0xa66f, 0xa672},   {0xa674, 0xa67d},   {0xa69e, 0xa69f},
      {0xa6f0, 0xa6f1},   {0xa802, 0xa802},   {0xa806, 0xa806},
      {0xa80b, 0xa80b},   {0xa823, 0xa827},   {0xa82c, 0xa82c},
      {0xa880, 0xa881},   {0xa8b4, 0xa8c5},   {0xa8e0, 0xa8f1},
      {0xa8ff, 0xa8ff},   {0xa926, 0xa92d},   {0xa947, 0xa953},
      {0xa980, 0xa983},   {0xa9b3, 0xa9c0},   {0xa9e5, 0xa9e5},
      {0xaa29, 0xaa36},   {0xaa43, 0xaa43},   {0xaa4c, 0xaa4d},
      {0xaa7b, 0xaa7d},   {0xaab0, 0xaab0},   {0xaab2, 0xaab4},
      {0xaab7, 0xaab8},   {0xaabe, 0xaabf},   {0xaac1, 0xaac1},
      {0xaaeb, 0xaaef},   {0xaaf5, 0xaaf6},   {0xabe3, 0xabea},
      {0xabec, 0xabed},   {0xfb1e, 0xfb1e},   {0xfe00, 0xfe0f},
      {0xfe20, 0xfe2f},   {0x101fd, 0x101fd}, {0x102e0, 0x102e0},
      {0x10376, 0x1037a}, {0x10a01, 0x10a03}, {0x10a05, 0x10a06},
      {0x10a0c, 0x10a0f}, {0x10a38, 0x10a3a}, {0x10a3f, 0x10a3f},
      {0x10ae5, 0x10ae6}, {0x10d24, 0x10d27}, {0x10eab, 0x10eac},
      {0x10f46, 0x10f50}, {0x11000, 0x11002}, {0x11038, 0x11046},
      {0x1107f, 0x11082}, {0x110b0, 0x110ba}, {0x11100, 0x11102},
      {0x11127, 0x11134}, {0x11145, 0x11146}, {0x11173, 0x11173},
      {0x11180, 0x11182}, {0x111b3, 0x111c0}, {0x111c9, 0x111cc},
      {0x111ce, 0x111cf}, {0x1122c, 0x11237}, {0x1123e, 0x1123e},
      {0x112df, 0x112ea}, {0x11300, 0x11303}, {0x1133b, 0x1133c},
      {0x1133e, 0x11344}, {0x11347, 0x11348}, {0x1134b, 0x1134d},
      {0x11357, 0x11357}, {0x11362, 0x11363}, {0x11366, 0x1136c},
      {0x11370, 0x11374}, {0x11435, 0x11446}, {0x1145e, 0x1145e},
      {0x114b0, 0x114c3}, {0x115af, 0x115b5}, {0x115b8, 0x115c0},
      {0x115dc, 0x115dd}, {0x11630, 0x11640}, {0x116ab, 0x116b7},
      {0x1171d, 0x1172b}, {0x1182c, 0x1183a}, {0x11930, 0x11935},
      {0x11937, 0x11938}, {0x1193b, 0x1193e}, {0x11940, 0x11940},
      {0x11942, 0x11943}, {0x119d1, 0x119d7}, {0x119da, 0x119e0},
      {0x119e4, 0x119e4}, {0x11a01, 0x11a0a}, {0x11a33, 0x11a39},
      {0x11a3b, 0x11a3e}, {0x11a47, 0x11a47}, {0x11a51, 0x11a5b},
      {0x11a8a, 0x11a99}, {0x11c2f, 0x11c36}, {0x11c38, 0x11c3f},
      {0x11c92, 0x11ca7}, {0x11ca9, 0x11cb6}, {0x11d31, 0x11d36},
      {0x11d3a, 0x11d3a}, {0x11d3c, 0x11d3d}, {0x11d3f, 0x11d45},
      {0x11d47, 0x11d47}, {0x11d8a, 0x11d8e}, {0x11d90, 0x11d91},
      {0x11d93, 0x11d97}, {0x11ef3, 0x11ef6}, {0x16af0, 0x16af4},
      {0x16b30, 0x16b36}, {0x16f4f, 0x16f4f}, {0x16f51, 0x16f87},
      {0x16f8f, 0x16f92}, {0x16fe4, 0x16fe4}, {0x16ff0, 0x16ff1},
      {0x1bc9d, 0x1bc9e}, {0x1d165, 0x1d169}, {0x1d16d, 0x1d172},
      {0x1d17b, 0x1d182}, {0x1d185, 0x1d18b}, {0x1d1aa, 0x1d1ad},
      {0x1d242, 0x1d244}, {0x1da00, 0x1da36}, {0x1da3b, 0x1da6c},
      {0x1da75, 0x1da75}, {0x1da84, 0x1da84}, {0x1da9b, 0x1da9f},
      {0x1daa1, 0x1daaf}, {0x1e000, 0x1e006}, {0x1e008, 0x1e018},
      {0x1e01b, 0x1e021}, {0x1e023, 0x1e024}, {0x1e026, 0x1e02a},
      {0x1e130, 0x1e136}, {0x1e2ec, 0x1e2ef}, {0x1e8d0, 0x1e8d6},
      {0x1e944, 0x1e94a}, {0xe0100, 0xe01ef}};

  return intable(combining, sizeof(combining), c);
}

/*
 * Return the number of bytes the UTF-8 encoding of the character at "p" takes.
 * This includes following composing characters.
 * Returns zero for NUL.
 */
int utfc_ptr2len(char_u *p) {
  int len;
  int b0 = *p;

  if (b0 == NUL)
    return 0;
  if (b0 < 0x80 && p[1] < 0x80) // be quick for ASCII
    return 1;

  // Skip over first UTF-8 char, stopping at a NUL byte.
  len = utf_ptr2len(p);

  // Check for illegal byte.
  if (len == 1 && b0 >= 0x80)
    return 1;

  /*
   * Check for composing characters.  We can handle only the first six, but
   * skip all of them (otherwise the cursor would get stuck).
   */
  for (;;) {
    if (p[len] < 0x80 || !utf_iscomposing(utf_ptr2char(p + len)))
      return len;

    len += utf_ptr2len(p + len);
  }
}

int utf_ptr2cells(char_u *p) {
  int c;

  // Need to convert to a character number.
  if (*p >= 0x80) {
    c = utf_ptr2char(p);
    // An illegal byte is displayed as <xx>.
    if (utf_ptr2len(p) == 1 || c == NUL)
      return 4;
    // If the char is ASCII it must be an overlong sequence.
    if (c < 0x80)
      return char2cells(c);
    return utf_char2cells(c);
  }
  return 1;
}

__attribute__((export_name("setAmbw"))) void setAmbw(int ambw) {
  ambiguousAsDouble = ambw;
}

/*
 * Return the number of cells occupied by string "p".
 * Stop at a NUL character.
 */
__attribute__((export_name("strWidth"))) int strWidth(char_u *p) {
  int i;
  int clen = 0;

  for (i = 0; p[i] != NUL; i += (*utfc_ptr2len)(p + i))
    clen += (*utf_ptr2cells)(p + i);
  return clen;
}
